import type { HandlerConfig, HandlerRequest, HandlerResponse, Tool } from '../utils/types.js';
import { log } from '../utils/logger.js';
import { createErrorResponse, createSuccessResponse } from '../utils/http-utility.js';
import type { Auth0Config } from '../utils/config.js';
import { getManagementClient } from '../utils/auth0-client.js';
import { claudeApi } from '../utils/claude-api.js';
import type { Auth0ClientData } from '../utils/terraform-field-mapper.js';
import { generateClientHclWithHeader } from '../utils/hcl-generator.js';
import {
  validateGitRepo,
  checkGhCli,
  createPRWithChanges,
  generateBranchName,
} from '../utils/git-operations.js';

// Default path for Auth0 client modules in Terraform repo
const DEFAULT_MODULE_PATH = 'modules/auth0/applications/clients/main.tf';

/**
 * Generate a standard PR description template
 */
function generateStandardPRDescription(client: Auth0ClientData, hcl: string): string {
  return `## Summary

Adds a new Auth0 client to Terraform configuration.

### Client Details
- **Name**: ${client.name}
- **Type**: ${client.app_type || 'Not specified'}
- **Client ID**: ${client.client_id}
${client.description ? `- **Description**: ${client.description}` : ''}

## Changes

- \`modules/auth0/applications/clients/main.tf\`: Added \`auth0_client\` resource${client.app_type === 'non_interactive' ? ' and `auth0_client_credentials` resource' : ''}

## Generated Terraform Code

\`\`\`hcl
${hcl}
\`\`\`

## Test Plan

- [ ] Run \`terraform plan\` to verify no syntax errors
- [ ] Verify resource attributes match Auth0 dashboard
- [ ] Test in non-production environment first

---
*Generated by Auth0 MCP Server*`;
}

/**
 * Generate a PR description using Claude API
 */
async function generateClaudePRDescription(client: Auth0ClientData, hcl: string): Promise<string> {
  try {
    const prompt = `Generate a professional pull request description for adding a new Auth0 client to our Terraform infrastructure repository.

Client Information:
- Name: ${client.name}
- Type: ${client.app_type || 'Not specified'}
- Client ID: ${client.client_id}
- Description: ${client.description || 'No description provided'}
${client.callbacks ? `- Callbacks: ${client.callbacks.join(', ')}` : ''}
${client.grant_types ? `- Grant Types: ${client.grant_types.join(', ')}` : ''}

Generated Terraform HCL:
\`\`\`hcl
${hcl}
\`\`\`

Please provide a PR description that includes:
1. A brief summary of what this client is for (infer from name/description)
2. Security considerations if any (based on app_type and configuration)
3. A testing checklist

Format the response in markdown with clear sections.`;

    const response = await claudeApi.chat([{ role: 'user', content: prompt }], {
      system:
        'You are an infrastructure engineer reviewing Terraform code for Auth0 integrations. Provide concise, professional PR descriptions.',
      max_tokens: 1024,
      temperature: 0.3,
    });

    return `${response}\n\n---\n*Generated by Auth0 MCP Server with Claude AI*`;
  } catch (error: any) {
    log(`Claude API failed, using standard template: ${error.message}`);
    return generateStandardPRDescription(client, hcl);
  }
}

// Define the terraform export tool
export const TERRAFORM_EXPORT_TOOLS: Tool[] = [
  {
    name: 'auth0_export_to_terraform_pr',
    description:
      'Export an Auth0 application to Terraform HCL format and create a PR in the infrastructure repository. Supports both direct client_id lookup and providing client_data directly. Requires gh CLI to be installed and authenticated.',
    inputSchema: {
      type: 'object',
      properties: {
        client_id: {
          type: 'string',
          description:
            'Auth0 client ID to export. The tool will fetch the client details from Auth0. Use this OR client_data, not both.',
        },
        client_data: {
          type: 'object',
          description:
            'Auth0 client data object directly (e.g., from auth0_create_application output or backup). Use this OR client_id, not both.',
        },
        terraform_repo_path: {
          type: 'string',
          description:
            'Absolute path to the Terraform repository where the PR will be created (e.g., /path/to/terraffirm). Required.',
        },
        target_file_path: {
          type: 'string',
          description:
            'Path to the Terraform file within the repo to append to. Defaults to modules/auth0/applications/clients/main.tf',
        },
        base_branch: {
          type: 'string',
          description: 'Base branch for the PR. Defaults to main.',
        },
        use_claude_for_pr: {
          type: 'boolean',
          description:
            'Use Claude API to generate an intelligent PR description. Requires Claude API key to be configured. Defaults to false.',
        },
        dry_run: {
          type: 'boolean',
          description:
            'If true, generate HCL but do not create branch/PR. Returns generated HCL for review. Defaults to false.',
        },
        use_variables_for_jwt: {
          type: 'boolean',
          description:
            'Use Terraform variables for JWT lifetime instead of hardcoded values. Defaults to true.',
        },
      },
      required: ['terraform_repo_path'],
    },
    _meta: {
      requiredScopes: ['read:clients'],
      readOnly: false,
    },
    annotations: {
      title: 'Export Auth0 Client to Terraform PR',
      readOnlyHint: false,
      destructiveHint: false,
      idempotentHint: false,
      openWorldHint: true, // Creates files and PRs externally
    },
  },
];

// Handler for terraform export tool
export const TERRAFORM_EXPORT_HANDLERS: Record<
  string,
  (request: HandlerRequest, config: HandlerConfig) => Promise<HandlerResponse>
> = {
  auth0_export_to_terraform_pr: async (
    request: HandlerRequest,
    config: HandlerConfig
  ): Promise<HandlerResponse> => {
    try {
      const {
        client_id,
        client_data,
        terraform_repo_path,
        target_file_path = DEFAULT_MODULE_PATH,
        base_branch = 'main',
        use_claude_for_pr = false,
        dry_run = false,
        use_variables_for_jwt = true,
      } = request.parameters;

      // Validate required parameters
      if (!terraform_repo_path) {
        return createErrorResponse('Error: terraform_repo_path is required');
      }

      if (!client_id && !client_data) {
        return createErrorResponse('Error: Either client_id or client_data is required');
      }

      if (client_id && client_data) {
        return createErrorResponse('Error: Provide either client_id or client_data, not both');
      }

      // Get client data
      let clientData: Auth0ClientData;

      if (client_id) {
        // Fetch from Auth0 API
        if (!request.token) {
          return createErrorResponse('Error: Missing authorization token for fetching client');
        }
        if (!config.domain) {
          return createErrorResponse('Error: Auth0 domain is not configured');
        }

        log(`Fetching client ${client_id} from Auth0...`);
        const managementClientConfig: Auth0Config = {
          domain: config.domain,
          token: request.token,
        };
        const managementClient = await getManagementClient(managementClientConfig);

        try {
          const response = await managementClient.clients.get({ client_id });
          clientData = response.data as Auth0ClientData;
        } catch (error: any) {
          if (error.statusCode === 404) {
            return createErrorResponse(`Error: Client not found: ${client_id}`);
          }
          throw error;
        }
      } else {
        // Use provided client data
        clientData = client_data as Auth0ClientData;
        if (!clientData.client_id || !clientData.name) {
          return createErrorResponse('Error: client_data must include at least client_id and name');
        }
      }

      log(`Processing client: ${clientData.name} (${clientData.client_id})`);

      // Generate Terraform HCL
      const hcl = generateClientHclWithHeader(clientData, {
        useVariableForJwtLifetime: use_variables_for_jwt,
        includeComments: true,
      });

      // If dry_run, return HCL without creating PR
      if (dry_run) {
        log('Dry run mode - returning generated HCL');
        return createSuccessResponse({
          status: 'dry_run',
          message: 'Generated Terraform HCL (dry run - no PR created)',
          client_name: clientData.name,
          client_id: clientData.client_id,
          generated_hcl: hcl,
          target_file: target_file_path,
        });
      }

      // Validate git repository
      const repoValidation = await validateGitRepo(terraform_repo_path);
      if (!repoValidation.valid) {
        return createErrorResponse(
          `Error: ${repoValidation.error?.message}${repoValidation.error?.recoveryAction ? `. ${repoValidation.error.recoveryAction}` : ''}`
        );
      }

      // Check gh CLI availability
      const ghCheck = await checkGhCli();
      if (!ghCheck.available) {
        return createErrorResponse(
          `Error: ${ghCheck.error?.message}${ghCheck.error?.recoveryAction ? `. ${ghCheck.error.recoveryAction}` : ''}`
        );
      }

      // Generate PR content
      const branchName = generateBranchName('client', clientData.name);
      const commitMessage = `feat(auth0): add ${clientData.name} client to Terraform`;
      const prTitle = `[Auth0] Add ${clientData.name} client`;

      // Generate PR description
      let prBody: string;
      if (use_claude_for_pr && claudeApi.isConfigured()) {
        log('Generating PR description with Claude API...');
        prBody = await generateClaudePRDescription(clientData, hcl);
      } else {
        prBody = generateStandardPRDescription(clientData, hcl);
      }

      // Create PR
      log(`Creating PR in ${terraform_repo_path}...`);
      const result = await createPRWithChanges(
        { repoPath: terraform_repo_path, baseBranch: base_branch },
        {
          branchName,
          filePath: target_file_path,
          content: hcl,
          commitMessage,
          prTitle,
          prBody,
        }
      );

      log(`Successfully created PR: ${result.prUrl}`);

      return createSuccessResponse({
        status: 'success',
        message: `Successfully created PR for ${clientData.name}`,
        pr_url: result.prUrl,
        branch_name: result.branchName,
        client_name: clientData.name,
        client_id: clientData.client_id,
        files_changed: result.filesChanged,
        generated_hcl: hcl,
      });
    } catch (error: any) {
      log(`Terraform export error: ${error.message}`);

      let errorMessage = `Failed to export to Terraform PR: ${error.message || 'Unknown error'}`;

      // Add context for common errors
      if (error.statusCode === 401) {
        errorMessage += '\nError: Unauthorized. Your Auth0 token might be expired or invalid.';
      } else if (error.statusCode === 403) {
        errorMessage += '\nError: Forbidden. Your token might not have read:clients scope.';
      } else if (error.message?.includes('gh')) {
        errorMessage += '\nError: GitHub CLI issue. Make sure gh is installed and authenticated.';
      } else if (error.message?.includes('git')) {
        errorMessage +=
          '\nError: Git operation failed. Check repository permissions and branch state.';
      }

      return createErrorResponse(errorMessage);
    }
  },
};
